using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Sharprompt.SourceGenerator;

[Generator(LanguageNames.CSharp)]
public sealed class PromptBindableGenerator : IIncrementalGenerator
{
    private const int DataTypePassword = 11;

    private static readonly SymbolDisplayFormat s_fullyQualifiedFormat = SymbolDisplayFormat.FullyQualifiedFormat;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "Sharprompt.PromptBindableAttribute",
                predicate: static (node, _) => node is ClassDeclarationSyntax,
                transform: static (syntaxContext, cancellationToken) => Transform(syntaxContext, cancellationToken))
            .Where(static x => x.Source.Length > 0);

        context.RegisterSourceOutput(provider, static (productionContext, file) =>
        {
            productionContext.AddSource(file.HintName, file.Source);
        });
    }

    private static (string HintName, string Source) Transform(GeneratorAttributeSyntaxContext syntaxContext, CancellationToken cancellationToken)
    {
        var typeSymbol = (INamedTypeSymbol)syntaxContext.TargetSymbol;
        var hintName = typeSymbol.ToDisplayString()
            .Replace('<', '_')
            .Replace('>', '_')
            .Replace(',', '_')
            .Replace(' ', '_')
            .Replace('.', '_')
            + ".Binder.g.cs";

        var source = GenerateSource(typeSymbol, cancellationToken);
        return (hintName, source ?? "");
    }

    private static string? GenerateSource(INamedTypeSymbol typeSymbol, CancellationToken cancellationToken)
    {
        var properties = new List<PropertyMetadata>();

        foreach (var property in GetAllPublicInstanceProperties(typeSymbol))
        {
            cancellationToken.ThrowIfCancellationRequested();

            if (property.SetMethod?.DeclaredAccessibility is not (Accessibility.Public or Accessibility.Internal or Accessibility.ProtectedOrInternal))
            {
                continue;
            }

            if (HasAttribute(property, "Sharprompt.BindIgnoreAttribute"))
            {
                continue;
            }

            properties.Add(Analyze(property, typeSymbol));
        }

        if (properties.Count == 0)
        {
            return null;
        }

        properties = properties.OrderBy(p => p.Order).ToList();

        var fullTypeName = typeSymbol.ToDisplayString(s_fullyQualifiedFormat);

        var builder = new StringBuilder();
        builder.AppendLine("// <auto-generated/>");
        builder.AppendLine("#nullable enable");
        builder.AppendLine();
        builder.AppendLine("file static class __SharpromptBinder_" + Sanitize(typeSymbol.ToDisplayString()));
        builder.AppendLine("{");
        builder.AppendLine("    [global::System.Runtime.CompilerServices.ModuleInitializer]");
        builder.AppendLine("    internal static void Register()");
        builder.AppendLine("    {");
        builder.AppendLine("        global::Sharprompt.ModelBinderRegistry.Register<" + fullTypeName + ">(model =>");
        builder.AppendLine("        {");

        for (var i = 0; i < properties.Count; i++)
        {
            if (i > 0)
            {
                builder.AppendLine();
            }

            Emit(builder, properties[i]);
        }

        builder.AppendLine("        });");
        builder.AppendLine("    }");
        builder.AppendLine("}");

        return builder.ToString();
    }

    private static IEnumerable<IPropertySymbol> GetAllPublicInstanceProperties(INamedTypeSymbol type)
    {
        var seen = new HashSet<string>();
        var current = type;

        while (current != null && current.SpecialType != SpecialType.System_Object)
        {
            foreach (var member in current.GetMembers())
            {
                if (member is IPropertySymbol { IsStatic: false, DeclaredAccessibility: Accessibility.Public } property &&
                    seen.Add(property.Name))
                {
                    yield return property;
                }
            }

            current = current.BaseType;
        }
    }

    private static PropertyMetadata Analyze(IPropertySymbol property, INamedTypeSymbol containingType)
    {
        var metadata = new PropertyMetadata { Name = property.Name };
        var propertyType = property.Type;

        metadata.FullTypeName = propertyType.ToDisplayString(s_fullyQualifiedFormat);

        // Unwrap Nullable<T>
        if (propertyType is INamedTypeSymbol { OriginalDefinition.SpecialType: SpecialType.System_Nullable_T } namedType)
        {
            metadata.UnderlyingType = namedType.TypeArguments[0];
        }
        else
        {
            metadata.UnderlyingType = propertyType;
        }

        metadata.UnderlyingTypeName = metadata.UnderlyingType.ToDisplayString(s_fullyQualifiedFormat);

        // Collection analysis
        var (isCollection, elementType) = AnalyzeCollection(propertyType);
        metadata.IsCollection = isCollection;

        if (elementType != null)
        {
            metadata.ElementTypeName = elementType.ToDisplayString(s_fullyQualifiedFormat);
            metadata.IsElementEnum = elementType.TypeKind == TypeKind.Enum;
        }

        // Enum check
        metadata.IsEnum = metadata.UnderlyingType.TypeKind == TypeKind.Enum;

        // Display attribute
        var displayAttribute = GetAttribute(property, "System.ComponentModel.DataAnnotations.DisplayAttribute");
        if (displayAttribute != null)
        {
            string? name = null, description = null;

            foreach (var arg in displayAttribute.NamedArguments)
            {
                switch (arg.Key)
                {
                    case "Name":
                        name = arg.Value.Value as string;
                        break;
                    case "Description":
                        description = arg.Value.Value as string;
                        break;
                    case "Prompt":
                        metadata.Placeholder = arg.Value.Value as string;
                        break;
                    case "Order":
                        metadata.Order = arg.Value.Value as int?;
                        break;
                }
            }

            metadata.Message = name ?? description ?? property.Name;
        }
        else
        {
            metadata.Message = property.Name;
        }

        // DataType attribute
        var dataTypeAttribute = GetAttribute(property, "System.ComponentModel.DataAnnotations.DataTypeAttribute");
        if (dataTypeAttribute is { ConstructorArguments.Length: > 0 })
        {
            if (dataTypeAttribute.ConstructorArguments[0].Value is int dataTypeValue)
            {
                metadata.IsPassword = dataTypeValue == DataTypePassword;
            }
        }

        // Validation attributes
        foreach (var attribute in property.GetAttributes())
        {
            if (attribute.AttributeClass != null && IsValidationAttribute(attribute.AttributeClass))
            {
                metadata.Validators.Add(GenerateNewExpression(attribute));
            }
        }

        // Items provider: InlineItems
        var inlineAttribute = GetAttribute(property, "Sharprompt.InlineItemsAttribute");
        if (inlineAttribute is { ConstructorArguments.Length: > 0 })
        {
            var arrayConstant = inlineAttribute.ConstructorArguments[0];
            if (arrayConstant.Kind == TypedConstantKind.Array)
            {
                var items = string.Join(", ", arrayConstant.Values.Select(FormatTypedConstant));
                var castType = metadata.ElementTypeName ?? metadata.UnderlyingTypeName;
                metadata.ItemsExpression = "global::System.Linq.Enumerable.Cast<" + castType + ">(new object[] { " + items + " })";
                metadata.HasItemsProvider = true;
            }
        }

        // Items provider: MemberItems
        if (!metadata.HasItemsProvider)
        {
            var memberAttribute = GetAttribute(property, "Sharprompt.MemberItemsAttribute");
            if (memberAttribute is { ConstructorArguments.Length: > 0 })
            {
                var memberName = memberAttribute.ConstructorArguments[0].Value as string;
                ITypeSymbol targetType = containingType;

                if (memberAttribute.ConstructorArguments.Length > 1 &&
                    memberAttribute.ConstructorArguments[1].Value is INamedTypeSymbol specifiedType)
                {
                    targetType = specifiedType;
                }

                if (memberName != null)
                {
                    var targetFullName = targetType.ToDisplayString(s_fullyQualifiedFormat);
                    var firstMember = targetType.GetMembers(memberName)
                        .FirstOrDefault(m => m.IsStatic && m.DeclaredAccessibility == Accessibility.Public);

                    if (firstMember is IPropertySymbol)
                    {
                        metadata.ItemsExpression = targetFullName + "." + memberName;
                        metadata.HasItemsProvider = true;
                    }
                    else if (firstMember is IMethodSymbol { Parameters.Length: 0 })
                    {
                        metadata.ItemsExpression = targetFullName + "." + memberName + "()";
                        metadata.HasItemsProvider = true;
                    }
                }
            }
        }

        // Determine form type
        metadata.FormType = DetermineFormType(metadata);

        // Determine type argument for generic Prompt methods
        metadata.TypeArg = metadata.FormType switch
        {
            FormKind.Input => metadata.FullTypeName,
            FormKind.Select => metadata.UnderlyingTypeName,
            FormKind.MultiSelect or FormKind.List => metadata.ElementTypeName ?? metadata.UnderlyingTypeName,
            _ => metadata.TypeArg
        };

        return metadata;
    }

    private static FormKind DetermineFormType(PropertyMetadata metadata)
    {
        if (metadata.IsPassword)
        {
            return FormKind.Password;
        }

        if (metadata.UnderlyingType?.SpecialType == SpecialType.System_Boolean)
        {
            return FormKind.Confirm;
        }

        var hasItems = metadata.HasItemsProvider || metadata.IsEnum || metadata.IsElementEnum;

        if (hasItems)
        {
            return metadata.IsCollection ? FormKind.MultiSelect : FormKind.Select;
        }

        return metadata.IsCollection ? FormKind.List : FormKind.Input;
    }

    private static void Emit(StringBuilder builder, PropertyMetadata property)
    {
        const string indent = "            ";

        switch (property.FormType)
        {
            case FormKind.Input:
                EmitInput(builder, property, indent);
                break;
            case FormKind.Password:
                EmitPassword(builder, property, indent);
                break;
            case FormKind.Confirm:
                EmitConfirm(builder, property, indent);
                break;
            case FormKind.Select:
                EmitSelect(builder, property, indent);
                break;
            case FormKind.MultiSelect:
                EmitMultiSelect(builder, property, indent);
                break;
            case FormKind.List:
                EmitList(builder, property, indent);
                break;
        }
    }

    private static void EmitInput(StringBuilder builder, PropertyMetadata property, string indent)
    {
        builder.AppendLine(indent + "model." + property.Name + " = global::Sharprompt.Prompt.Input<" + property.TypeArg + ">(options =>");
        builder.AppendLine(indent + "{");
        builder.AppendLine(indent + "    options.Message = " + Quote(property.Message) + ";");

        if (property.Placeholder != null)
        {
            builder.AppendLine(indent + "    options.Placeholder = " + Quote(property.Placeholder) + ";");
        }

        builder.AppendLine(indent + "    options.DefaultValue = model." + property.Name + ";");
        EmitValidators(builder, property, indent);
        builder.AppendLine(indent + "});");
    }

    private static void EmitPassword(StringBuilder builder, PropertyMetadata property, string indent)
    {
        builder.AppendLine(indent + "model." + property.Name + " = global::Sharprompt.Prompt.Password(options =>");
        builder.AppendLine(indent + "{");
        builder.AppendLine(indent + "    options.Message = " + Quote(property.Message) + ";");

        if (property.Placeholder != null)
        {
            builder.AppendLine(indent + "    options.Placeholder = " + Quote(property.Placeholder) + ";");
        }

        EmitValidators(builder, property, indent);
        builder.AppendLine(indent + "});");
    }

    private static void EmitConfirm(StringBuilder builder, PropertyMetadata property, string indent)
    {
        builder.AppendLine(indent + "model." + property.Name + " = global::Sharprompt.Prompt.Confirm(options =>");
        builder.AppendLine(indent + "{");
        builder.AppendLine(indent + "    options.Message = " + Quote(property.Message) + ";");
        builder.AppendLine(indent + "    options.DefaultValue = model." + property.Name + ";");
        builder.AppendLine(indent + "});");
    }

    private static void EmitSelect(StringBuilder builder, PropertyMetadata property, string indent)
    {
        builder.AppendLine(indent + "model." + property.Name + " = global::Sharprompt.Prompt.Select<" + property.TypeArg + ">(options =>");
        builder.AppendLine(indent + "{");
        builder.AppendLine(indent + "    options.Message = " + Quote(property.Message) + ";");

        if (property.ItemsExpression != null)
        {
            builder.AppendLine(indent + "    options.Items = " + property.ItemsExpression + ";");
        }

        builder.AppendLine(indent + "    options.DefaultValue = model." + property.Name + ";");
        builder.AppendLine(indent + "});");
    }

    private static void EmitMultiSelect(StringBuilder builder, PropertyMetadata property, string indent)
    {
        builder.AppendLine(indent + "model." + property.Name + " = global::Sharprompt.Prompt.MultiSelect<" + property.TypeArg + ">(options =>");
        builder.AppendLine(indent + "{");
        builder.AppendLine(indent + "    options.Message = " + Quote(property.Message) + ";");

        if (property.ItemsExpression != null)
        {
            builder.AppendLine(indent + "    options.Items = " + property.ItemsExpression + ";");
        }

        builder.AppendLine(indent + "    options.DefaultValues = model." + property.Name + " ?? global::System.Array.Empty<" + property.TypeArg + ">();");
        builder.AppendLine(indent + "});");
    }

    private static void EmitList(StringBuilder builder, PropertyMetadata property, string indent)
    {
        builder.AppendLine(indent + "model." + property.Name + " = global::Sharprompt.Prompt.List<" + property.TypeArg + ">(options =>");
        builder.AppendLine(indent + "{");
        builder.AppendLine(indent + "    options.Message = " + Quote(property.Message) + ";");
        builder.AppendLine(indent + "    options.DefaultValues = model." + property.Name + " ?? global::System.Array.Empty<" + property.TypeArg + ">();");
        EmitValidators(builder, property, indent);
        builder.AppendLine(indent + "});");
    }

    private static void EmitValidators(StringBuilder builder, PropertyMetadata property, string indent)
    {
        foreach (var validator in property.Validators)
        {
            builder.AppendLine(indent + "    {");
            builder.AppendLine(indent + "        var __v = " + validator + ";");
            builder.AppendLine(indent + "        var __c = new global::System.ComponentModel.DataAnnotations.ValidationContext(model) { DisplayName = " + Quote(property.Name) + ", MemberName = " + Quote(property.Name) + " };");
            builder.AppendLine(indent + "        options.Validators.Add(input => __v.GetValidationResult(input, __c));");
            builder.AppendLine(indent + "    }");
        }
    }

    #region Helpers

    private static bool HasAttribute(ISymbol symbol, string fullName)
    {
        return symbol.GetAttributes().Any(a => a.AttributeClass?.ToDisplayString() == fullName);
    }

    private static AttributeData? GetAttribute(ISymbol symbol, string fullName)
    {
        return symbol.GetAttributes().FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == fullName);
    }

    private static bool IsValidationAttribute(ITypeSymbol type)
    {
        var current = type.BaseType;

        while (current != null)
        {
            if (current.ToDisplayString() == "System.ComponentModel.DataAnnotations.ValidationAttribute")
            {
                return true;
            }

            current = current.BaseType;
        }

        return false;
    }

    private static (bool IsCollection, ITypeSymbol? ElementType) AnalyzeCollection(ITypeSymbol type)
    {
        if (type.SpecialType == SpecialType.System_String)
        {
            return (false, null);
        }

        if (type is IArrayTypeSymbol arrayType)
        {
            return (true, arrayType.ElementType);
        }

        if (type is INamedTypeSymbol namedType)
        {
            if (namedType.OriginalDefinition.SpecialType == SpecialType.System_Collections_Generic_IEnumerable_T)
            {
                return (true, namedType.TypeArguments[0]);
            }

            foreach (var interfaceType in namedType.AllInterfaces)
            {
                if (interfaceType.OriginalDefinition.SpecialType == SpecialType.System_Collections_Generic_IEnumerable_T)
                {
                    return (true, interfaceType.TypeArguments[0]);
                }
            }
        }

        return (false, null);
    }

    private static string GenerateNewExpression(AttributeData attribute)
    {
        var builder = new StringBuilder();
        builder.Append("new ");
        builder.Append(attribute.AttributeClass!.ToDisplayString(s_fullyQualifiedFormat));
        builder.Append('(');

        for (var i = 0; i < attribute.ConstructorArguments.Length; i++)
        {
            if (i > 0)
            {
                builder.Append(", ");
            }

            builder.Append(FormatTypedConstant(attribute.ConstructorArguments[i]));
        }

        builder.Append(')');

        if (attribute.NamedArguments.Length > 0)
        {
            builder.Append(" { ");

            for (var i = 0; i < attribute.NamedArguments.Length; i++)
            {
                if (i > 0)
                {
                    builder.Append(", ");
                }

                builder.Append(attribute.NamedArguments[i].Key);
                builder.Append(" = ");
                builder.Append(FormatTypedConstant(attribute.NamedArguments[i].Value));
            }

            builder.Append(" }");
        }

        return builder.ToString();
    }

    private static string FormatTypedConstant(TypedConstant typedConstant)
    {
        if (typedConstant.IsNull)
        {
            return "null";
        }

        switch (typedConstant.Kind)
        {
            case TypedConstantKind.Primitive:
                return typedConstant.Value switch
                {
                    string s => Quote(s),
                    bool b => b ? "true" : "false",
                    char c => "'" + EscapeChar(c) + "'",
                    float => typedConstant.Value + "f",
                    double => typedConstant.Value + "d",
                    decimal => typedConstant.Value + "m",
                    long => typedConstant.Value + "L",
                    ulong => typedConstant.Value + "UL",
                    _ => typedConstant.Value?.ToString() ?? "null"
                };

            case TypedConstantKind.Enum:
                return "(" + typedConstant.Type!.ToDisplayString(s_fullyQualifiedFormat) + ")" + typedConstant.Value;

            case TypedConstantKind.Type:
                return "typeof(" + ((ITypeSymbol)typedConstant.Value!).ToDisplayString(s_fullyQualifiedFormat) + ")";

            case TypedConstantKind.Array:
                var elements = string.Join(", ", typedConstant.Values.Select(FormatTypedConstant));
                return "new " + typedConstant.Type!.ToDisplayString(s_fullyQualifiedFormat) + " { " + elements + " }";

            default:
                return typedConstant.Value?.ToString() ?? "null";
        }
    }

    private static string Quote(string text)
    {
        return "\"" + text.Replace("\\", "\\\\").Replace("\"", "\\\"").Replace("\n", "\\n").Replace("\r", "\\r") + "\"";
    }

    private static string EscapeChar(char c)
    {
        return c switch
        {
            '\\' => "\\\\",
            '\'' => "\\'",
            '\n' => "\\n",
            '\r' => "\\r",
            '\t' => "\\t",
            _ => c.ToString()
        };
    }

    private static string Sanitize(string name)
    {
        var builder = new StringBuilder(name.Length);

        foreach (var c in name)
        {
            builder.Append(char.IsLetterOrDigit(c) ? c : '_');
        }

        return builder.ToString();
    }

    #endregion

    #region Data structures

    private enum FormKind
    {
        Input,
        Password,
        Confirm,
        Select,
        MultiSelect,
        List
    }

    private sealed class PropertyMetadata
    {
        public string Name { get; set; } = "";
        public string FullTypeName { get; set; } = "";
        public ITypeSymbol? UnderlyingType { get; set; }
        public string UnderlyingTypeName { get; set; } = "";
        public string? ElementTypeName { get; set; }
        public bool IsCollection { get; set; }
        public bool IsEnum { get; set; }
        public bool IsElementEnum { get; set; }
        public string Message { get; set; } = "";
        public string? Placeholder { get; set; }
        public int? Order { get; set; }
        public bool IsPassword { get; set; }
        public FormKind FormType { get; set; }
        public string? TypeArg { get; set; }
        public List<string> Validators { get; set; } = [];
        public string? ItemsExpression { get; set; }
        public bool HasItemsProvider { get; set; }
    }

    #endregion
}
